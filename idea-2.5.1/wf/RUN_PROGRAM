#!/usr/bin/perl

use File::Basename;
use strict;
$|++;


# Get the username
my $username = `whoami`;
chomp($username);
$username = 'unknown' if (!$username);

# Create a '.workflow.$USER.$$' file
my $wf_pid_file = ".workflow.".$username."."."$$";

#Create a log file to log messages from this script
open(LOG, "> $wf_pid_file".".log") or die "Could not create log file: $!\n";

# stores process id of forked child process
my $child_pid;

# The child command that invokes the other runworkflow script.  
my $child_command; 

# Flag that indicates to wait for the Workflow to complete or not
my $wait = "true";

# This flag indicates that the script is invoked with the help flag
my $help = "false";

# Flag used to avoid sending multiple kill commands
my $flag = "false";

# Default return value of child
my $def_child_ret = -1;

# Actual return value of the child, initially equals to the default value
my $c_ret = $def_child_ret;


print LOG "$0 ($$): Parent with pid $$, starting.\n";

# check to see if a wait and help flags are specified in the arguments
for (@ARGV) {
	if (/\-\-help/) {
		$help = "true";
	}
}

# parent process


$child_pid = fork;

if (defined $child_pid) {
		if ($child_pid !=0) {
			print LOG "$0 ($$): Child created with pid $child_pid\n";
			#print "$0 ($$): Child created with pid $child_pid\n";

			install_sig_handler();

			# If the user requested to wait, then wait until the 
			# workflow is complete.
			if ("$wait" eq "true") {
				print LOG "$0 ($$): Waiting for the Child to complete. \n";

				# Wait for the child to finish
				wait;

				# Get the child process's return value and exit with that return value.
				$c_ret = $? >> 8;

				print LOG "$0 ($$): Child returned with $c_ret \n";
				print LOG "$0 ($$): Parent exiting.\n";
				close(LOG);

				# Remove the pid file and the pid log file, before exiting.
				unlink $wf_pid_file;
				unlink $wf_pid_file.".log";
					
				exit $c_ret;
			} # end if wait flag is specified

			print "$0 ($$): Parent Exiting....\n";
			# end of parent process
			exit();
		} else {
			# child process
			print LOG "$0 ($$): Child with pid $$, starting .\n";
			$child_command = &getScriptNameToInvoke("$0")." @ARGV"." --pidfile $wf_pid_file";
			print LOG "$0 ($$): Child command is '$child_command'\n";

			# invoke the child command with system command
			print LOG "$0 ($$): Child invoking the command.\n";

			# Invoke the child command
			system($child_command);
			my $ret = $?;
			$ret = $ret >> 8;

			# exit with return value
			exit $ret;
		}#end of child 
} else {
	# error 
    print LOG "$0 ($$): unable to fork, exiting\n";
    #print "$0 ($$): unable to fork, exiting\n";
    exit(1);
}


###############  SUBROUTINES  ################################

# Subroutine that creates the workflow pid file
sub create_pid_file {
	# Write the child pid and invocation string to the pid file
	open(PIDFILE, ">> $wf_pid_file");
	print PIDFILE "pid = $$\n";
	print PIDFILE "invocation = $0 @ARGV\n";
	print LOG "$0 ($$): The Workflow is invoked.\n";
	print "The Workflow is invoked. View Workflow Monitor to check the progress. \n";
	close(PIDFILE);
}

sub install_sig_handler {
	# trap SIGINT, SIGTERM and SIGHUP
	$SIG{'INT'} = \&sighandler;
	$SIG{'TERM'} = \&sighandler;
	$SIG{'HUP'} = \&sighandler;
	$SIG{'USR1'} = \&sighandler;
	$SIG{'USR2'} = \&sighandler;
}

# subroutine that will handle SIGINT
sub sighandler {
    my $signame = shift;
    print LOG "$0 ($$): caught signal $signame\n";
    
	if ($flag eq "false") {
		$flag = "true";
		if (defined($child_pid)) {

	    	# kill returns number of processes successfully signaled
		print LOG "Calling kill 2, $child_pid \n";
	    	my $count = kill 2, $child_pid; 
		    if ($count != 1) {
				print LOG "$0 ($$): Error signaling the Workflow process; manual intervention may be required\n";
				unlink $wf_pid_file;
				unlink $wf_pid_file.".log";
			} else {
				print LOG "$0 ($$): Successfully signaled the Workflow process\n";
				unlink $wf_pid_file;
				unlink $wf_pid_file.".log";
				print LOG "$0 ($$): Successfully signaled the Workflow process.\n";
			}
		} else {
		    print LOG "$0 ($$): child_pid not defined, no signal sent!\n";
		}
    }
}

# This subroutine returns the appropriate script name to be invoked by the current script
# based on the name that the current script was invoked as. 
# by the current script.
sub getScriptNameToInvoke {
	my $called_as = shift;
	my $script="";	
	$called_as = basename($called_as);
	print LOG "The base name is : $called_as\n";

	if ($called_as eq 'RunWorkflow') {
		$script = "run_workflow";
		# Create the pid file
		create_pid_file();
	} elsif ($called_as eq 'CreateWorkflow') {
		$script = "create_workflow";
	} elsif ($called_as eq 'MonitorWorkflow') {
		$script = "workflow_monitor";
	} elsif ($called_as eq 'EditTemplate') {
		$script = "workflow_editor";
	} elsif ($called_as eq 'EditWorkflow') {
		$script = "workflow_editor";
	} elsif ($called_as eq 'CheckWorkflow') {
		$script = "check_workflow";
	} elsif ($called_as eq 'ControlWorkflow') {
		$script = "control_workflow";
	} elsif ($called_as eq 'KillWorkflow') {
		$script = "kill_workflow";
	} elsif ($called_as eq 'RunTestSuite') {
		$script = "run_test_suite";
	} elsif ($called_as eq 'CleanWorkflowRegistry') {
		$script = "clean_workflow_registry";
	} else {
		print "Unrecognized Command \n";
		exit 255;
	}
	$script;	
}
