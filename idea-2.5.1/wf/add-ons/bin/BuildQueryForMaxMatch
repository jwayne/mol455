#!/usr/bin/perl -w
# This script takes a a multi-fasta query file and concatenates all the queries
# into a single sequence to pre-filter the database using max-match.
#
# <p>Copyright (C) 2001, The Institute for Genomic Research (TIGR).
#
# <p>All rights reserved.
#
# <pre>
# $RCSfile: BuildQueryForMaxMatch,v $
# $Revision: 1.1 $
# $Date: 2003/07/29 13:12:26 $
# $Author: amahurka $
# </pre>
#

use strict;
use Getopt::Long;
use Data::Dumper;
use Log::Log4perl qw(:levels get_logger);

my $usage = <<USAGE_INFO;
Usage: BuildQueryForMaxMatch --query=<query file> --out<output file> --logconf=<logging configuration>
USAGE_INFO

my $help_info = <<HELP_INFO;
This script takes a a multi-fasta query file and concatenates all the queries
into a single sequence to pre-filter the database using max-match.

Usage: BuildQueryForMaxMatch --query=<query file> --out<output file>
       --logconf=<logging configuration>

Example: BuiBuildQueryForMaxMatch --query=MyQuery.dat --out=MyQueryForMAM.dat
HELP_INFO

my $global_log_conf = '/usr/local/devel/ANNOTATION/panda/etc/logger.conf';
my ($qry_name, $out_name, $help, $usage, $logger_conf, $debug);
my %matched_hash = ();  # A hash to hold the list of proteins with protein match

GetOptions ("query=s"      => \$qry_name,
            "out=s"        => \$out_name,
            "help"         => \$help,
            "usage"        => \$usage,
            "logconf=s"    => \$logger_conf,
            "debug=s"      => \$debug,
            );

# If usage or help requested print help info
if ($help) {
    print $help;
    exit;
}

if ($usage) {
    print $usage;
    exit;
}

# Decide if the global logging configuration file is to be used ot the one specified
# by the user
$logger_conf = $logger_conf || "logger.conf";
if ($logger_conf) {
    # Check that the file exists, is a text file, and that it is readable.
    if ( -e $logger_conf && -T $logger_conf && -r $logger_conf) {
        $logger_conf = $logger_conf;
    } else {
        warn("Problem with the specified logger config file. Using global default.");
        $logger_conf = $global_log_conf;
    }
} else {
    $logger_conf = $global_log_conf;
}

# Set up the logger specification through the conf file
Log::Log4perl->init($logger_conf);
my $logger = get_logger("TIGR");

# Override the debug level if it is specified by the user
&set_debug_level if $debug;

$logger->info("Processing query file '$qry_name'\n");
 
if ($out_name) {
    open OUT, ">$out_name" or &error("Could not open output file '$out_name'");
    select OUT;
}

open QRY, $qry_name or error("Could not open query file '$qry_name'");
while (<QRY>) {
    
    # If this line is a header line  and not the first line then ignore
    if (m/^>/) {
        if ($. == 1) {
            print;
        }
    } elsif (m/^[A-Z]/) {
        print;
    }
}

close QRY;

if ($out_name) {
    close OUT;
}

exit 0;

# Override the debug level specified by the configuration
# file with the value specified by the user
sub set_debug_level {
    unless ($debug) {
        return; # If the user has nt specified a debug then do nothing
    }
    $logger->error("In the set_debug_level subroutine. Changing debug level to $debug.");

    my $debug = uc($debug);

    my %levels = ( DEBUG => [5, $DEBUG],
                   INFO  => [4, $INFO],
                   WARN  => [3, $WARN],
                   ERROR => [2, $ERROR],
                   FATAL => [1, $FATAL] );
    my %name_to_level = map { $_ => $levels{$_}->[1] } keys %levels;

    my $setter = sub {
        my $level_string = shift;
        $logger->info("Setting new debug level to $level_string.");
        my $level = $name_to_level{$level_string};
        $logger->level($level);
    };

    if (exists $levels{$debug}) {
        $setter->($debug);
    } else {
        $debug =~ tr/0-9//cd;
        if ($debug >= 1 and $debug <= 5) {
            my %level_to_name = reverse ( map { $_ => $levels{$_}->[0] } keys %levels );
            $setter->( $level_to_name{$debug} );
        } else {
            $logger->warn("\"$debug\" is an invalid debug level.");
            return 0;
        }
    }
}

# This subroutine sends a fatal error and dies
sub error {
    my ($msg) = @_;
    $logger->fatal($msg);
    die;
}
