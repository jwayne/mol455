#!/usr/bin/perl -w
# This script takes a clustered output file generated by the max-match program 
# to build the database file. The script first identifies the proteins with matches
# to build the matched list, it then parses the database file to only write out the proteins
# that are in the matched list.
#
# <p>Copyright (C) 2001, The Institute for Genomic Research (TIGR).
#
# <p>All rights reserved.
#
# <pre>
# $RCSfile: BuildDBFromMatches,v $
# $Revision: 1.1 $
# $Date: 2003/07/29 13:12:26 $
# $Author: amahurka $
# </pre>
#

use strict;
use Getopt::Long;
use Data::Dumper;
use Log::Log4perl qw(:levels get_logger);

my $usage_msg = <<USAGE_INFO;
Usage: BuildDBFromMatches --cluster=<cluster file> --db=<database file> --out=<output file> 
       --logconf=<logging configuration>
USAGE_INFO

my $help_info = <<HELP_INFO;
This script takes a clustered output file generated by the max-match program
to build the database file. The script first identifies the proteins with matches
to build the matched list, it then parses the database file to only write out the proteins
that are in the matched list.

Usage: BuildDBFromMatches --cluster=<cluster file> --db=<database file> --out=<output file> 
       --logconf=<logging configuration>

Example: BuildDBFromMatches --cluster=MyTest.clst --db=MyTestDB.dat  --out=FilteredMyTestDB.dat
HELP_INFO
    
my $global_log_conf = '/usr/local/devel/ANNOTATION/panda/etc/logger.conf';
my ($db_name, $clst_name, $out_name, $help, $usage, $logger_conf, $debug);
my %matched_hash = ();  # A hash to hold the list of proteins with protein match

GetOptions ("cluster=s"    => \$clst_name,
            "db=s"         => \$db_name,
            "out=s"        => \$out_name,
            "help"         => \$help,
            "usage"        => \$usage,
            "logconf=s"    => \$logger_conf,
            "debug=s"      => \$debug,
            );

# If usage or help requested print help info
if ($help) {
    print $help;
    exit;
}

if ($usage) {
    print $usage;
    exit;
}

# Decide if the global logging configuration file is to be used ot the one specified
# by the user
$logger_conf = $logger_conf || "logger.conf";
if ($logger_conf) {
    # Check that the file exists, is a text file, and that it is readable.
    if ( -e $logger_conf && -T $logger_conf && -r $logger_conf) {
        $logger_conf = $logger_conf;
    } else {
        warn("Problem with the specified logger config file. Using global default.");
        $logger_conf = $global_log_conf;
    }
} else {
    $logger_conf = $global_log_conf;
}

# Set up the logger specification through the conf file
Log::Log4perl->init($logger_conf);
my $logger = get_logger("TIGR");

# Override the debug level if it is specified by the user
&set_debug_level if $debug;

$logger->info("Processing cluster file '$clst_name' database '$db_name'\n");

# Read the list of proteins from the cluster file and build the list of proteins
# with matches
open CLST, $clst_name or &error("Could not open cluster file '$clst_name'");

my $new_entry = 0;
my $accumulate = 0;
my $match_count = 0;
my $prev_protein;
my $cur_protein;
my $cur_entry;
my $next_entry;

while (<CLST>) {
    
    # If this line is a header line then start accumulating
    # match count
    if (m/^>\s?(.+)$/) {
    
        $cur_protein = $1;
        
        $logger->debug("Current: $cur_protein Previous: $prev_protein Previous match count: $match_count\n");

        # If there is a previous protein defined then
        # add it to the matched hash based on the match count
        if ($prev_protein && ($match_count > 0)) {
            $logger->debug("Matched protein: $prev_protein\n");
            $matched_hash{$prev_protein} = 1;
        }

        $prev_protein = $cur_protein;
        $match_count = 0;
    } elsif (m/^\s+/) {
        # $logger->debug("Incrementing match count for protein: $prev_protein\n");

        # As this is not a header line and not starting with # then increment match
        # count
        $match_count++;
    }
}

# At the end if the match count is greater than zero add last protein
if ($match_count > 0) {
    $matched_hash{$prev_protein} = 1;
}
close CLST;

$logger->info("Finished identifying cluster matches.\n");

# if the out has been specified then select that
if ($out_name) {
    open OUT, ">$out_name" or &error("Could not create file '$out_name'\n");
    select OUT;
}

foreach my $match (keys %matched_hash) {
    $logger->debug(">$match\n");
}

# Open the specified database file and write out the proteins that are in the matched list
open DB, "$db_name" or &error("Could not open database file '$db_name'.\n");
while (my $entry = &read_protein) {
    my $identifier = &get_identifier($entry);

    $logger->debug("Processing protein with identifier: $identifier\n");
    if (exists $matched_hash{$identifier}) {
        $logger->debug("This protein has a match, so will write the protein.\n");
        print $entry;
    }
}
close DB;
$logger->info("Finished writing matched proteins.\n");

if ($out_name) {
    close OUT;
}
exit 0;

# This subroutine reads the next protein entry in the specified
# FASTA file
sub read_protein {
    $cur_entry = $next_entry; # Mode the next entry contents into the current entry
    
    while (<DB>) {
        # If the line starts with a > then this is the header line
        # If this is the first record then accumulate to the current entry
        if (m/^>/) {

            # If this is not the first record then a new entry has begun
            # so return the accumulated entry
            if ($. != 1) {
                $next_entry = $_;
                $logger->debug("Returning the protein entry: $cur_entry\n");
                return $cur_entry;
                last;
            } else {
                $cur_entry .= $_;
            }
        } else {
            $cur_entry .= $_;
        }
    }
        
    # As the last entry has been reached set the next entry to be blank
    # so that in the next request it returns blank
    $next_entry = "";
    $logger->debug("Returning the last protein entry: $cur_entry\n");
    return $cur_entry;
}

# Read the protein identifier for the protein FASTA entry
sub get_identifier {
    my ($entry) = @_;

    #$entry =~ m/^>([0-9\|A-Za-z]+)\s/;
    $entry =~ m/^>(\S+)/;
    chomp $entry;

    # If the identifier could not be read then not much can be done so die
    &error("Could not identify the FASTA identifier for entry: $entry") if (!$entry);

    return $1;
}

# Override the debug level specified by the configuration
# file with the value specified by the user
sub set_debug_level {
    unless ($debug) {
        return; # If the user has nt specified a debug then do nothing
    }
    $logger->error("In the set_debug_level subroutine. Changing debug level to $debug.");

    my $debug = uc($debug);

    my %levels = ( DEBUG => [5, $DEBUG],
                   INFO  => [4, $INFO],
                   WARN  => [3, $WARN],
                   ERROR => [2, $ERROR],
                   FATAL => [1, $FATAL] );
    my %name_to_level = map { $_ => $levels{$_}->[1] } keys %levels;

    my $setter = sub {
        my $level_string = shift;
        $logger->info("Setting new debug level to $level_string.");
        my $level = $name_to_level{$level_string};
        $logger->level($level);
    };

    if (exists $levels{$debug}) {
        $setter->($debug);
    } else {
        $debug =~ tr/0-9//cd;
        if ($debug >= 1 and $debug <= 5) {
            my %level_to_name = reverse ( map { $_ => $levels{$_}->[0] } keys %levels );
            $setter->( $level_to_name{$debug} );
        } else {
            $logger->warn("\"$debug\" is an invalid debug level.");
            return 0;
        }
    }
}

# This subroutine sends a fatal error and dies
sub error {
    my ($msg) = @_;
    $logger->fatal($msg);
    die;
}
